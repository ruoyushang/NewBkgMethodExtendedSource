//
// 
// This code uses the histograms generated by GetShowerImageHistograms() and creates hadronic background predictions.
// Author: Ruo Yu Shang
//
//
#include <cstdlib>
#include <vector>
#include <iostream>
#include <sstream>
#include <fstream>
#include <map>
#include <string>
#include <iomanip>
#include <stdio.h>
#include <utility>

#include <algorithm>
#include <functional>

#include "TFile.h"
#include "TF1.h"
#include "TH1.h"
#include "TH2.h"
#include "TProfile.h"
#include "TGraph.h"
#include "TTree.h"
#include "TString.h"
#include "TSystem.h"
#include "TROOT.h"
#include "TChain.h"
#include "TBranch.h"
#include "TSpectrum.h"

#include "GetShowerImageHistograms.C"


void Deconvolution(TH1* Hist_source, TH1* Hist_response, TH1* Hist_Deconv, int n_iteration) {
        Hist_Deconv->Reset();
        const int N_bins = Hist_source->GetNbinsX();
        Double_t *source = new Double_t[N_bins];
        Double_t *response = new Double_t[N_bins];
        for (int i=0;i<N_bins;i++) {
            source[i] = max(Hist_source->GetBinContent(i+1),0.);
            //if (Hist_source->GetBinCenter(i+1)<MSCW_cut_lower) source[i] = 0.;
            if (i<N_bins/2) 
            {
                response[i] = max(Hist_response->GetBinContent(i+1+N_bins/2),0.);
                //if (Hist_source->GetBinCenter(i+1+N_bins/2)<MSCW_cut_lower) source[i] = 0.;
            }
            else response[i] = 0;
        }
        TSpectrum sp;
        sp.Deconvolution(source,response,N_bins,n_iteration,1,100000); // new best option
        for (int i=0;i<N_bins;i++) {
            Hist_Deconv->SetBinContent(i+1,max(source[i],0.));
            Hist_Deconv->SetBinError(i+1,pow(max(source[i],0.),0.5));
        }
}
double GetChi2(TH1* Hist_SR, TH1* Hist_Bkg, bool includeSR, int chi2_type) {
    if (Hist_Bkg->Integral()==0) return 0.;
    double chi2_temp = 0.;
    double nbins = 0.;
    for (int i=0;i<Hist_SR->GetNbinsX();i++) {
        double bkg = Hist_Bkg->GetBinContent(i+1);
        double data = Hist_SR->GetBinContent(i+1);
        double bkg_err = Hist_Bkg->GetBinError(i+1);
        double data_err = Hist_SR->GetBinError(i+1);
        //if (Hist_Bkg->GetBinCenter(i+1)>4.) continue;
        if (!includeSR && Hist_Bkg->GetBinCenter(i+1)>MSCW_cut_lower && Hist_Bkg->GetBinCenter(i+1)<MSCW_cut_blind) {
            continue;
        }
        if ((data_err*data_err+bkg_err*bkg_err)==0) data_err = 1.;
        chi2_temp += pow(bkg-data,2)/(data_err*data_err+bkg_err*bkg_err);
        //if ((data_err*data_err)==0) data_err = 1.;
        //chi2_temp += pow(bkg-data,2)/(data_err*data_err);
        nbins += 1.;
    }
    chi2_temp = chi2_temp/nbins;
    double chi2_total = 1.;
    if (includeSR || chi2_type==1) 
    {
        chi2_total = chi2_temp;
    }
    else
    {
        chi2_total = chi2_temp;
    }
    chi2_total = 1./chi2_total;
    return chi2_total;
}
double ShiftAndNormalize(TH1* Hist_SR, TH1* Hist_BkgTemp, TH1* Hist_Bkg, bool doShift, bool includeSR, int chi2_type, double shift_begin) {
    double shift_fit = 0;
    double unblinded_shift_fit = 0;
    double scale_fit = 0;
    double chi2 = 0.;
    double unblinded_chi2 = 0.;
    double mean = Hist_SR->GetMean();
    double rms = Hist_SR->GetRMS();
    double norm = Hist_BkgTemp->Integral();
    Hist_Bkg->Reset();
    int norm_bin_low = Hist_SR->FindBin(MSCW_cut_lower);
    int norm_bin_blind = Hist_SR->FindBin(MSCW_cut_blind);
    int norm_bin_up = Hist_SR->FindBin(30.);
    if (includeSR) {
        for (int fit=0;fit<100;fit++) {
                double shift = shift_begin-1.0*rms/2.+2.0*rms/2.*double(fit)*0.01;
                for (int i=0;i<Hist_SR->GetNbinsX();i++) {
                        int b = Hist_SR->FindBin(Hist_SR->GetBinCenter(i+1)-shift);
                        Hist_Bkg->SetBinContent(i+1,Hist_BkgTemp->GetBinContent(b));
                        Hist_Bkg->SetBinError(i+1,Hist_BkgTemp->GetBinError(b));
                }
                Hist_Bkg->Scale(norm/Hist_Bkg->Integral());
                norm_bin_low = Hist_SR->FindBin(mean-8.*rms);
                norm_bin_up = Hist_SR->FindBin(MSCW_cut_lower);
                double SR_area1 = Hist_SR->Integral(norm_bin_low,norm_bin_up);
                double Bkg_area1 = Hist_Bkg->Integral(norm_bin_low,norm_bin_up);
                norm_bin_low = Hist_SR->FindBin(MSCW_cut_blind);
                norm_bin_up = Hist_SR->FindBin(mean+8.*rms);
                double SR_area2 = Hist_SR->Integral(norm_bin_low,norm_bin_up);
                double Bkg_area2 = Hist_Bkg->Integral(norm_bin_low,norm_bin_up);
                double scale_begin = (SR_area1+SR_area2)/(Bkg_area1+Bkg_area2);
                //double scale_begin = (SR_area2)/(Bkg_area2);
                double scale = scale_begin;
                Hist_Bkg->Scale(norm/Hist_Bkg->Integral());
                Hist_Bkg->Scale(scale);
                double chi2_temp = GetChi2(Hist_SR, Hist_Bkg,includeSR,1);
                double unblinded_chi2_temp = GetChi2(Hist_SR, Hist_Bkg,true,1);
                if (chi2<chi2_temp && Hist_Bkg->Integral()!=0) {
                    chi2 = chi2_temp;
                    shift_fit = shift;
                    scale_fit = scale;
                } 
                if (unblinded_chi2<unblinded_chi2_temp && Hist_Bkg->Integral()!=0) {
                    unblinded_chi2 = unblinded_chi2_temp;
                    unblinded_shift_fit = shift;
                } 
        }
    }
    else {
        for (int i=0;i<Hist_SR->GetNbinsX();i++) {
                int b = Hist_SR->FindBin(Hist_SR->GetBinCenter(i+1)-shift_begin);
                Hist_Bkg->SetBinContent(i+1,Hist_BkgTemp->GetBinContent(b));
                Hist_Bkg->SetBinError(i+1,Hist_BkgTemp->GetBinError(b));
        }
        Hist_Bkg->Scale(norm/Hist_Bkg->Integral());
        norm_bin_low = Hist_SR->FindBin(mean-8.*rms);
        norm_bin_up = Hist_SR->FindBin(MSCW_cut_lower);
        double SR_area1 = Hist_SR->Integral(norm_bin_low,norm_bin_up);
        double Bkg_area1 = Hist_Bkg->Integral(norm_bin_low,norm_bin_up);
        norm_bin_low = Hist_SR->FindBin(MSCW_cut_blind);
        norm_bin_up = Hist_SR->FindBin(mean+8.*rms);
        double SR_area2 = Hist_SR->Integral(norm_bin_low,norm_bin_up);
        double Bkg_area2 = Hist_Bkg->Integral(norm_bin_low,norm_bin_up);
        scale_fit = (SR_area1+SR_area2)/(Bkg_area1+Bkg_area2);
        shift_fit = shift_begin;
    }
    for (int i=0;i<Hist_SR->GetNbinsX();i++) {
            int b = Hist_Bkg->FindBin(Hist_Bkg->GetBinCenter(i+1)-shift_fit);
            Hist_Bkg->SetBinContent(i+1,Hist_BkgTemp->GetBinContent(b));
            Hist_Bkg->SetBinError(i+1,Hist_BkgTemp->GetBinError(b));
    }
    if (Hist_BkgTemp->Integral()==0) 
    {
        std::cout << "Hist_BkgTemp->Integral() = 0!!!" << std::endl;
    }
    if (Hist_Bkg->Integral()==0) 
    {
        std::cout << "Hist_Bkg->Integral() = 0!!!" << std::endl;
        for (int i=0;i<Hist_SR->GetNbinsX();i++) {
                Hist_Bkg->SetBinContent(i+1,0.);
                Hist_Bkg->SetBinError(i+1,0.);
        }
    }
    else 
    {
        Hist_Bkg->Scale(norm/Hist_Bkg->Integral());
    }
    Hist_Bkg->Scale(scale_fit);
    return shift_fit;
}
double ConvergeFunction(double x, double endpoint_0, double endpoint_1, int type)
{
    if (x-(endpoint_1)>=0.) return 1.;
    if (x-(endpoint_0)<0.) return 0.;
    return pow((x-endpoint_0)/(endpoint_1-endpoint_0),1);
    //return 1./(1.+exp(-(x-(endpoint_0+endpoint_1)/2.)/(endpoint_1-endpoint_0)));

}
void Converge(TH1* Hist_Bkg, double endpoint_0, double endpoint_1)
{
    for (int i=0;i<Hist_Bkg->GetNbinsX();i++)
    {
        double old_content = Hist_Bkg->GetBinContent(i+1);
        double new_content = old_content*ConvergeFunction(Hist_Bkg->GetBinCenter(i+1),endpoint_0,endpoint_1,0);
        double old_error = Hist_Bkg->GetBinError(i+1);
        double new_error = old_error;
        Hist_Bkg->SetBinContent(i+1,new_content);
        Hist_Bkg->SetBinError(i+1,new_error);
    }
}
double Kernel(Double_t *x, Double_t *par) {
    double xx =x[0];
    return exp(-0.5*pow((xx)/(par[0]),2));
}
bool IsReasonableResult(TH1* Hist_Bkg)
{
    double total_bkg = 0.;
    double total_err = 0.;
    for (int i=0;i<Hist_Bkg->GetNbinsX();i++)
    {
        total_bkg += Hist_Bkg->GetBinContent(i);
        total_err += Hist_Bkg->GetBinError(i);
    }
    if (total_bkg<=0.) return false;
    if (total_err/total_bkg>10.) return false;
    return true;
}
double FindRMS(TH1* Hist_SR, TH1* Hist_CR, TH1* Hist_Bkg, TH1* Hist_BkgTemp, TH1* Hist_Deconv, double rms_begin, double mean, double n_iter, bool includeSR, int chi2_type, double endpoint_0, double endpoint_1) {
    bool DoShift = true;
    double chi2_best = 0.;
    double rms_final = rms_begin;
    double unblinded_chi2_best = 0.;
    double unblinded_rms_final = rms_begin;
    int final_n_rms = 0;
    TF1 *func = new TF1("func",Kernel,-50.,50.,1);
    func->SetParameter(0,0.5);
    for (int n_rms = 0; n_rms<=40;n_rms++) {
        double chi2 = 0;
        double unblinded_chi2 = 0;
        double rms = rms_begin;
        //rms = 0.1+double(n_rms+1)*2.0/40.;
        rms = Hist_CR->GetRMS()*double(n_rms+1)/40.;
        //if (!includeSR) rms = rms_begin*(0.5+double(n_rms)*1.5/40.);
        func->SetParameter(0,rms);
        Hist_Deconv->Reset();
        for (int b=0;b<Hist_Deconv->GetNbinsX();b++)
        {
            double content = func->Eval(Hist_Deconv->GetBinCenter(b+1));
            Hist_Deconv->SetBinContent(b+1,content);
            Hist_Deconv->SetBinError(b+1,pow(content,0.5));
        }
        Deconvolution(Hist_CR,Hist_Deconv,Hist_BkgTemp,n_iter);
        if (!IsReasonableResult(Hist_BkgTemp)) continue;
        double offset = ShiftAndNormalize(Hist_SR,Hist_BkgTemp,Hist_Bkg,DoShift,includeSR,chi2_type,0.);
        Converge(Hist_Bkg,endpoint_0,endpoint_1);
        chi2 = GetChi2(Hist_SR, Hist_Bkg,includeSR,2);
        unblinded_chi2 = GetChi2(Hist_SR, Hist_Bkg,true,2);
        if (chi2_best<chi2) {
            chi2_best = chi2;
            rms_final = rms;
            final_n_rms = n_rms;
        } 
        if (unblinded_chi2_best<unblinded_chi2) {
            unblinded_chi2_best = unblinded_chi2;
            unblinded_rms_final = rms;
        } 
    }
    return rms_final;
}
void MakeBkgPrevious(TH1* Hist_SR,TH1* Hist_Bkg,TH1* Hist_Previous, bool includeSR)
{
    for (int i=0;i<Hist_SR->GetNbinsX();i++)
    {
        if (Hist_Bkg->GetBinCenter(i+1)<MSCW_cut_blind && !includeSR)
        //if (!includeSR)
        {
            Hist_Previous->SetBinContent(i+1,Hist_Bkg->GetBinContent(i+1));
            Hist_Previous->SetBinError(i+1,Hist_Bkg->GetBinError(i+1));
        }
        else
        {
            Hist_Previous->SetBinContent(i+1,Hist_SR->GetBinContent(i+1));
            Hist_Previous->SetBinError(i+1,Hist_SR->GetBinError(i+1));
        }
    }
    if (Hist_Previous->Integral()==0) 
    {
        std::cout << "Hist_Previous->Integral() = 0!!!" << std::endl;
    }
}
std::pair <double,double> FindConvergeEndpoints(TH1* Hist_SR,TH1* Hist_Bkg,double init_endpoint_0,double init_endpoint_1)
{
    double endpoint_0_best = 0.;
    double endpoint_1_best = 0.;
    double chi2_best = 0.;
    for (int ep0=0;ep0<=50;ep0++) 
    {
        double tmp_endpoint_0 = -1.0+1.0*double(ep0)/50.;
        for (int ep1=0;ep1<=50;ep1++) 
        {
            double tmp_endpoint_1 = tmp_endpoint_0+1.0*double(ep1)/50.;
            TH1D Hist_Bkg_Tmp = TH1D("Hist_Bkg_Tmp","",Hist_SR->GetNbinsX(),MSCW_plot_lower,MSCW_plot_upper);
            Hist_Bkg_Tmp.Reset();
            Hist_Bkg_Tmp.Add(Hist_Bkg);
            Converge(&Hist_Bkg_Tmp,tmp_endpoint_0,tmp_endpoint_1);
            double chi2 = GetChi2(Hist_SR,&Hist_Bkg_Tmp,true,1);
            if (chi2_best<chi2) {
                chi2_best = chi2;
                endpoint_0_best = tmp_endpoint_0;
                endpoint_1_best = tmp_endpoint_1;
            } 
        }
    }
    return std::make_pair(endpoint_0_best,endpoint_1_best);

}
std::pair <std::pair<double,double>,std::pair <double,double>> PredictNextLayerHadron(int niter, double electron_flux_scale, TH1* Hist_ElectronMC, TH1* Hist_SR, TH1* Hist_SR_Previous,TH1* Hist_Bkg, TH1* Hist_Bkg_Previous, double energy, std::pair <std::pair <double,double>,std::pair <double,double>> parameters, bool isDark)
{
    Hist_Bkg->Reset();
    TH1D Hist_Bkg_Privous_Adapt = TH1D("Hist_Bkg_Privous_Adapt","",Hist_SR->GetNbinsX(),MSCW_plot_lower,MSCW_plot_upper);
    MakeBkgPrevious(Hist_SR_Previous,Hist_Bkg_Previous,&Hist_Bkg_Privous_Adapt,false);
    //MakeBkgPrevious(Hist_SR_Previous,Hist_Bkg_Previous,&Hist_Bkg_Privous_Adapt,isDark);

    TH1D Hist_SR_Temp = TH1D("Hist_SR_Temp","",Hist_SR->GetNbinsX(),MSCW_plot_lower,MSCW_plot_upper);
    Hist_SR_Temp.Reset();
    for (int b=0;b<Hist_SR_Temp.GetNbinsX();b++)
    {
        double content = 0;
        content = Hist_SR->GetBinContent(b+1)-Hist_ElectronMC->GetBinContent(b+1)*electron_flux_scale;
        if (content<0.) content = 0.;
        double error = Hist_SR->GetBinError(b+1);
        Hist_SR_Temp.SetBinContent(b+1,content);
        Hist_SR_Temp.SetBinError(b+1,error);
    }

    TH1D Hist_Bkg_Temp = TH1D("Hist_Bkg_Temp","",Hist_SR->GetNbinsX(),MSCW_plot_lower,MSCW_plot_upper);
    TH1D Hist_Kernel = TH1D("Hist_Kernel","",Hist_SR->GetNbinsX(),MSCW_plot_lower,MSCW_plot_upper);
    int SR_Niter=niter;
    double kernel_rms = parameters.first.first;
    double offset_begin = parameters.first.second;
    double endpoint_0 = parameters.second.first;
    double endpoint_1 = parameters.second.second;
    if (isDark) kernel_rms = FindRMS(&Hist_SR_Temp,&Hist_Bkg_Privous_Adapt,Hist_Bkg,&Hist_Bkg_Temp,&Hist_Kernel,kernel_rms,0,SR_Niter,true,1,endpoint_0,endpoint_1);
    TF1 *myfunc = new TF1("myfunc",Kernel,-50.,50.,1);
    myfunc->SetParameter(0,kernel_rms);
    Hist_Kernel.Reset();
    for (int b=0;b<Hist_Kernel.GetNbinsX();b++)
    {
        double content = myfunc->Eval(Hist_Kernel.GetBinCenter(b+1));
        Hist_Kernel.SetBinContent(b+1,content);
        Hist_Kernel.SetBinError(b+1,pow(content,0.5));
    }
                    
    Deconvolution(&Hist_Bkg_Privous_Adapt,&Hist_Kernel,&Hist_Bkg_Temp,SR_Niter);
    double offset = ShiftAndNormalize(&Hist_SR_Temp,&Hist_Bkg_Temp,Hist_Bkg,true,isDark,2,offset_begin);

    Hist_SR_Temp.Reset();
    for (int b=0;b<Hist_SR_Temp.GetNbinsX();b++)
    {
        double content = 0;
        content = Hist_SR->GetBinContent(b+1)-Hist_ElectronMC->GetBinContent(b+1)*electron_flux_scale;
        if (content<0.) content = 0.;
        double error = Hist_SR->GetBinError(b+1);
        Hist_SR_Temp.SetBinContent(b+1,content);
        Hist_SR_Temp.SetBinError(b+1,error);
    }
    std::pair <double,double> converge;
    converge.first = endpoint_0;
    converge.second = endpoint_1;
    if (isDark)
    {
        converge = FindConvergeEndpoints(&Hist_SR_Temp,Hist_Bkg,endpoint_0,endpoint_1);
    }
    Converge(Hist_Bkg,converge.first,converge.second);
    parameters.first.first = kernel_rms;
    parameters.first.second = offset;
    parameters.second.first = converge.first;
    parameters.second.second = converge.second;
    return parameters;
}
std::pair <std::pair<double,double>,std::pair <double,double>> PredictNextLayer(TH1* Hist_Dark_ElectronMC, TH1* Hist_ElectronMC, TH1* Hist_SR, TH1* Hist_SR_Previous,TH1* Hist_Bkg, TH1* Hist_Bkg_Previous, TH1* Hist_DarkSR, TH1* Hist_DarkSR_Previous, TH1* Hist_DarkBkg, TH1* Hist_DarkBkg_Previous, std::pair <std::pair <double,double>,std::pair <double,double>> parameters_0, double energy)
{
    std::pair <std::pair <double,double>,std::pair <double,double>> parameters;
    double chi2_best = 0.;
    double chi2_previous = 0.;
    int niter_best = 0;
    for (int niter=1;niter<=10;niter++)
    {
        parameters = PredictNextLayerHadron(niter,0.0,Hist_Dark_ElectronMC,Hist_DarkSR,Hist_DarkSR_Previous,Hist_DarkBkg,Hist_DarkBkg_Previous,energy,parameters_0,true);
        double chi2 = GetChi2(Hist_DarkSR,Hist_DarkBkg,true,1);
        //if (chi2_previous>chi2) break;
        if (chi2_best<chi2) {
            chi2_best = chi2;
            niter_best = niter;
        } 
        chi2_previous = chi2;
    }

    chi2_best = 0.;
    double best_electron_scale = 0.;
    for (int nscale=0;nscale<=10;nscale++)
    {
        double scale = 2.0*(double)nscale/10.;
        parameters = PredictNextLayerHadron(niter_best,scale,Hist_Dark_ElectronMC,Hist_DarkSR,Hist_DarkSR_Previous,Hist_DarkBkg,Hist_DarkBkg_Previous,energy,parameters_0,true);
        double chi2 = GetChi2(Hist_DarkSR,Hist_DarkBkg,true,1);
        if (chi2_best<chi2) {
            chi2_best = chi2;
            best_electron_scale = scale;
        } 
    }
    parameters = PredictNextLayerHadron(niter_best,best_electron_scale,Hist_Dark_ElectronMC,Hist_DarkSR,Hist_DarkSR_Previous,Hist_DarkBkg,Hist_DarkBkg_Previous,energy,parameters_0,true);

    std::cout << "best_electron_scale = " << best_electron_scale << std::endl;
    std::cout << "Dark field found kernel RMS = " << parameters.first.first << std::endl;
    std::cout << "Dark field found kernel offset = " << parameters.first.second << std::endl;
    std::cout << "Dark field found endpoint 0 = " << parameters.second.first << std::endl;
    std::cout << "Dark field found endpoint 1 = " << parameters.second.second << std::endl;

    parameters = PredictNextLayerHadron(niter_best,best_electron_scale,Hist_ElectronMC,Hist_SR,Hist_SR_Previous,Hist_Bkg,Hist_Bkg_Previous,energy,parameters,false);
    //parameters = PredictNextLayerHadron(niter_best,best_electron_scale,Hist_ElectronMC,Hist_SR,Hist_SR_Previous,Hist_Bkg,Hist_Bkg_Previous,energy,parameters_0,true);
    std::cout << "Dark bkg integral = " << Hist_DarkBkg->Integral() << std::endl;
    std::cout << "Target bkg integral = " << Hist_Bkg->Integral() << std::endl;
    Hist_Dark_ElectronMC->Scale(best_electron_scale);
    Hist_ElectronMC->Scale(best_electron_scale);
    return parameters;

}
void PredictBackground(TH2D* Hist_Target_Data, TH2D* Hist_Target_Elec, TH2D* Hist_Dark_Data, TH2D* Hist_Dark_Elec, TH2D* Hist_Target_Bkg, TH2D* Hist_Dark_Bkg, double energy)
{
    std::pair <std::pair <double,double>,std::pair <double,double>> parameters;
    for (int binx=1;binx<Number_of_CR;binx++)
    {
        int region = Hist_Target_Data->GetNbinsX()-binx;
        std::cout << "region = " << region << std::endl;
        TH1* Hist_Dark_ElectronMC = Hist_Dark_Elec->ProjectionY("Hist_Dark_ElectronMC",region,region);
        TH1* Hist_Target_ElectronMC = Hist_Target_Elec->ProjectionY("Hist_Target_ElectronMC",region,region);
        TH1* Hist_SR = Hist_Target_Data->ProjectionY("Hist_SR",region,region);
        TH1* Hist_SR_Previous = Hist_Target_Data->ProjectionY("Hist_SR_Previous",region+1,region+1);
        TH1* Hist_Bkg = Hist_Target_Bkg->ProjectionY("Hist_Bkg",region,region);
        TH1* Hist_Bkg_Previous = Hist_Target_Bkg->ProjectionY("Hist_Bkg_Previous",region+1,region+1);
        if (binx==1) Hist_Bkg_Previous = Hist_Target_Data->ProjectionY("Hist_Bkg_Previous",region+1,region+1);
        TH1* Hist_DarkSR = Hist_Dark_Data->ProjectionY("Hist_DarkSR",region,region);
        TH1* Hist_DarkSR_Previous = Hist_Dark_Data->ProjectionY("Hist_DarkSR_Previous",region+1,region+1);
        TH1* Hist_DarkBkg = Hist_Dark_Bkg->ProjectionY("Hist_DarkBkg",region,region);
        TH1* Hist_DarkBkg_Previous = Hist_Dark_Bkg->ProjectionY("Hist_DarkBkg_Previous",region+1,region+1);
        if (binx==1) Hist_DarkBkg_Previous = Hist_Dark_Data->ProjectionY("Hist_DarkBkg_Previous",region+1,region+1);
        std::cout << "Before, Hist_Target_ElectronMC->Integral() = " << Hist_Target_ElectronMC->Integral() << std::endl;
        parameters = PredictNextLayer(Hist_Dark_ElectronMC,Hist_Target_ElectronMC,Hist_SR,Hist_SR_Previous,Hist_Bkg,Hist_Bkg_Previous,Hist_DarkSR,Hist_DarkSR_Previous,Hist_DarkBkg,Hist_DarkBkg_Previous,parameters,energy);
        std::cout << "After, Hist_Target_ElectronMC->Integral() = " << Hist_Target_ElectronMC->Integral() << std::endl;
        for (int biny=0;biny<Hist_Target_Bkg->GetNbinsY();biny++)
        {
            Hist_Target_Bkg->SetBinContent(region,biny+1,Hist_Bkg->GetBinContent(biny+1));
            Hist_Target_Bkg->SetBinError(region,biny+1,Hist_Bkg->GetBinError(biny+1));
            Hist_Dark_Bkg->SetBinContent(region,biny+1,Hist_DarkBkg->GetBinContent(biny+1));
            Hist_Dark_Bkg->SetBinError(region,biny+1,Hist_DarkBkg->GetBinError(biny+1));
            Hist_Target_Elec->SetBinContent(region,biny+1,Hist_Target_ElectronMC->GetBinContent(biny+1));
            Hist_Target_Elec->SetBinError(region,biny+1,Hist_Target_ElectronMC->GetBinError(biny+1));
            Hist_Dark_Elec->SetBinContent(region,biny+1,Hist_Dark_ElectronMC->GetBinContent(biny+1));
            Hist_Dark_Elec->SetBinError(region,biny+1,Hist_Dark_ElectronMC->GetBinError(biny+1));
        }
    }
    for (int binx=0;binx<Number_of_SR;binx++)
    {
        int region = Hist_Target_Data->GetNbinsX()-binx-Number_of_CR;
        std::cout << "region = " << region << std::endl;
        TH1* Hist_Dark_ElectronMC = Hist_Dark_Elec->ProjectionY("Hist_Dark_ElectronMC",region,region);
        TH1* Hist_Target_ElectronMC = Hist_Target_Elec->ProjectionY("Hist_Target_ElectronMC",region,region);
        TH1* Hist_SR = Hist_Target_Data->ProjectionY("Hist_SR",region,region);
        TH1* Hist_SR_Previous = Hist_Target_Data->ProjectionY("Hist_SR_Previous",region+1,region+1);
        TH1* Hist_Bkg = Hist_Target_Bkg->ProjectionY("Hist_Bkg",region,region);
        TH1* Hist_Bkg_Previous = Hist_Target_Bkg->ProjectionY("Hist_Bkg_Previous",region+1,region+1);
        if (binx==0) Hist_Bkg_Previous = Hist_Target_Data->ProjectionY("Hist_Bkg_Previous",region+1,region+1);
        TH1* Hist_DarkSR = Hist_Dark_Data->ProjectionY("Hist_DarkSR",region,region);
        TH1* Hist_DarkSR_Previous = Hist_Dark_Data->ProjectionY("Hist_DarkSR_Previous",region+1,region+1);
        TH1* Hist_DarkBkg = Hist_Dark_Bkg->ProjectionY("Hist_DarkBkg",region,region);
        TH1* Hist_DarkBkg_Previous = Hist_Dark_Bkg->ProjectionY("Hist_DarkBkg_Previous",region+1,region+1);
        if (binx==0) Hist_DarkBkg_Previous = Hist_Dark_Data->ProjectionY("Hist_DarkBkg_Previous",region+1,region+1);
        std::cout << "Before, Hist_Target_ElectronMC->Integral() = " << Hist_Target_ElectronMC->Integral() << std::endl;
        parameters = PredictNextLayer(Hist_Dark_ElectronMC,Hist_Target_ElectronMC,Hist_SR,Hist_SR_Previous,Hist_Bkg,Hist_Bkg_Previous,Hist_DarkSR,Hist_DarkSR_Previous,Hist_DarkBkg,Hist_DarkBkg_Previous,parameters,energy);
        std::cout << "After, Hist_Target_ElectronMC->Integral() = " << Hist_Target_ElectronMC->Integral() << std::endl;
        for (int biny=0;biny<Hist_Target_Bkg->GetNbinsY();biny++)
        {
            Hist_Target_Bkg->SetBinContent(region,biny+1,Hist_Bkg->GetBinContent(biny+1));
            Hist_Target_Bkg->SetBinError(region,biny+1,Hist_Bkg->GetBinError(biny+1));
            Hist_Dark_Bkg->SetBinContent(region,biny+1,Hist_DarkBkg->GetBinContent(biny+1));
            Hist_Dark_Bkg->SetBinError(region,biny+1,Hist_DarkBkg->GetBinError(biny+1));
            Hist_Target_Elec->SetBinContent(region,biny+1,Hist_Target_ElectronMC->GetBinContent(biny+1));
            Hist_Target_Elec->SetBinError(region,biny+1,Hist_Target_ElectronMC->GetBinError(biny+1));
            Hist_Dark_Elec->SetBinContent(region,biny+1,Hist_Dark_ElectronMC->GetBinContent(biny+1));
            Hist_Dark_Elec->SetBinError(region,biny+1,Hist_Dark_ElectronMC->GetBinError(biny+1));
        }
    }
}
void RecurrentDeconvolution(string target_data, string dark_data, double theta2_cut_lower_input, double theta2_cut_upper_input)
{

    Theta2_cut_lower = theta2_cut_lower_input;
    Theta2_cut_upper = theta2_cut_upper_input;

    vector<TH2D> Hist_Target_Bkg_MSCLW;
    vector<TH2D> Hist_Dark_Bkg_MSCLW;
    TFile InputDataFile("output_Jun15/Deconvolution_"+TString(target_data)+"_Theta2"+std::to_string(int(10.*Theta2_cut_lower))+"to"+std::to_string(int(10.*Theta2_cut_upper))+".root");
    TFile InputDarkFile("output_Jun15/Deconvolution_"+TString(dark_data)+"_Theta2"+std::to_string(int(10.*Theta2_cut_lower))+"to"+std::to_string(int(10.*Theta2_cut_upper))+".root");
    for (int e=0;e<N_energy_bins;e++) 
    {
        std::cout << "energy = " << energy_bins[e] << std::endl;
        char e_low[50];
        sprintf(e_low, "%i", int(energy_bins[e]));
        char e_up[50];
        sprintf(e_up, "%i", int(energy_bins[e+1]));
        TString filename_data  = "Hist_Data_MSCLW_ErecS"+TString(e_low)+TString("to")+TString(e_up);
        TString filename_elec  = "Hist_Elec_MSCLW_ErecS"+TString(e_low)+TString("to")+TString(e_up);
        TH2D* Hist_Target_Data = (TH2D*)InputDataFile.Get(filename_data);
        TH2D* Hist_Target_Elec = (TH2D*)InputDataFile.Get(filename_elec);
        TH2D* Hist_Dark_Data = (TH2D*)InputDarkFile.Get(filename_data);
        TH2D* Hist_Dark_Elec = (TH2D*)InputDarkFile.Get(filename_elec);

        N_bins_for_deconv = Hist_Target_Data->GetNbinsY();
        Hist_Target_Bkg_MSCLW.push_back(TH2D("Hist_Target_Bkg_MSCLW_ErecS"+TString(e_low)+TString("to")+TString(e_up),"",Number_of_SR+Number_of_CR,MSCL_signal_cut_lower[Number_of_SR-1],MSCL_control_cut_upper[0],N_bins_for_deconv,MSCW_plot_lower,MSCW_plot_upper));
        Hist_Dark_Bkg_MSCLW.push_back(TH2D("Hist_Dark_Bkg_MSCLW_ErecS"+TString(e_low)+TString("to")+TString(e_up),"",Number_of_SR+Number_of_CR,MSCL_signal_cut_lower[Number_of_SR-1],MSCL_control_cut_upper[0],N_bins_for_deconv,MSCW_plot_lower,MSCW_plot_upper));

        //if (use_this_energy_bin[e]==false) continue;
        PredictBackground(Hist_Target_Data,Hist_Target_Elec,Hist_Dark_Data,Hist_Dark_Elec,&Hist_Target_Bkg_MSCLW.at(e),&Hist_Dark_Bkg_MSCLW.at(e),energy_bins[e]);

    }
    InputDataFile.Close();
    InputDarkFile.Close();

    TFile OutputDataFile("output_Jun15/Deconvolution_"+TString(target_data)+"_Theta2"+std::to_string(int(10.*Theta2_cut_lower))+"to"+std::to_string(int(10.*Theta2_cut_upper))+".root","update");
    for (int e=0;e<N_energy_bins;e++)
    {
        Hist_Target_Bkg_MSCLW.at(e).Write();
    }
    OutputDataFile.Close();

}
